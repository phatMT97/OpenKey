//
// External global variables (still needed for now - will refactor later)
extern int vLanguage;
extern int vInputType;
extern int vCodeTable;
extern bool vCheckSpelling;
extern bool vFreeMark;
extern bool vModernStyle;
extern bool vUseMacro;
extern bool vQuickStartConsonant;
extern bool vQuickEndConsonant;
extern bool vRestoreIfWrongSpelling;
extern bool vUpperCaseFirstChar;
extern bool vQuickTelex;

// External helper functions (keep as static helpers for now)
extern bool isWordBreak(const vKeyEvent& event, const vKeyEventState& state, const Uint16& data);
extern bool isMacroBreakCode(const int& data);
extern bool findMacro(vector<Uint32>& key, vector<Uint32>& macroContentCode);
extern bool checkRestoreIfWrongSpelling(const HoolCodeState& state);
extern void checkQuickConsonant();
extern void checkSpelling(const bool& forceCheckVowel);
extern void checkGrammar(const int& deltaBackSpace);
extern void insertKey(const Uint16& keyCode, const bool& isCaps);
extern void insertState(const Uint16& keyCode, const bool& isCaps);
extern void handleMainKey(const Uint16& data, const bool& isCaps);
extern void handleQuickTelex(const Uint16& data, const bool& isCaps);
extern void upperCaseFirstCharacter();

// External state (will be refactored incrementally)
extern Byte hBPC, hNCC, hExt;
extern HoolCodeState hCode;
extern Uint32 hData[MAX_BUFF];
extern vector<Uint32> hMacroKey, hMacroData;
extern int _spaceCount;
extern int _upperCaseStatus;

VietnameseEngine::VietnameseEngine() 
    : index(0)
    , stateIndex(0)
    , tempDisableKey(false)
    , isCaps(false)
    , useSpellCheckingBefore(false)
    , hasHandledMacro(false)
    , hasHandleQuickConsonant(false)
    , willTempOffEngine(false)
{
    // Initialize arrays to zero
    typingWord.fill(0);
    keyStates.fill(0);
    
    // Initialize hook state
    hookState.code = 0;
    hookState.backspaceCount = 0;
    hookState.newCharCount = 0;
    hookState.extCode = 0;
    for (int i = 0; i < MAX_BUFF; i++) {
        hookState.charData[i] = 0;
    }
}

VietnameseEngine::~VietnameseEngine() {
    // Cleanup if needed
}

void VietnameseEngine::handleEvent(const vKeyEvent& event, 
                                   const vKeyEventState& state,
                                   const uint16_t& data,
                                   const uint8_t& capsStatus,
                                   const bool& otherControlKey) {
    // NOTE: This is a hybrid implementation - uses class members where possible
    // but still calls external helpers. Full refactoring will move helpers to class.
    
    isCaps = (capsStatus == 1 || capsStatus == 2); // shift or caps lock
    
    if ((IS_NUMBER_KEY(data) && capsStatus == 1)
        || otherControlKey || isWordBreak(event, state, data) || (index == 0 && IS_NUMBER_KEY(data))) {
        hCode = vDoNothing;
        hBPC = 0;
        hNCC = 0;
        hExt = 1; //word break
        
        //check macro feature
        if (vUseMacro && isMacroBreakCode(data) && !hasHandledMacro && findMacro(hMacroKey, hMacroData)) {
            hCode = vReplaceMaro;
            hBPC = (Byte)hMacroKey.size();
            hasHandledMacro = true;
        } else if ((vQuickStartConsonant || vQuickEndConsonant) && !tempDisableKey && isMacroBreakCode(data)) {
            checkQuickConsonant();
        } else if (vRestoreIfWrongSpelling && isWordBreak(event, state, data)) {
            if (!tempDisableKey && vCheckSpelling) {
                checkSpelling(true);
            }
            if (tempDisableKey && !checkRestoreIfWrongSpelling(vRestoreAndStartNewSession)) {
                hCode = vDoNothing;
            }
        }
        
        // Handle special chars (will refactor to use class members)
        if (hCode == vDoNothing) {
            startNewSession();
            vCheckSpelling = useSpellCheckingBefore;
            willTempOffEngine = false;
        } else if (hCode == vReplaceMaro || hasHandleQuickConsonant) {
            index = 0;
        }
        
        //insert key for macro function
        if (vUseMacro) {
            // macroKey will be in class later
        }
        
        if (vUpperCaseFirstChar) {
            if (data == KEY_DOT)
                _upperCaseStatus = 1;
            else if (data == KEY_ENTER || data == KEY_RETURN)
                _upperCaseStatus = 2;
            else
                _upperCaseStatus = 0;
        }
    } else if (data == KEY_SPACE) {
        if (!tempDisableKey && vCheckSpelling) {
            checkSpelling(true);
        }
        if (vUseMacro && !hasHandledMacro && findMacro(hMacroKey, hMacroData)) {
            hCode = vReplaceMaro;
            hBPC = (Byte)hMacroKey.size();
            _spaceCount++;
            hasHandledMacro = true;
        } else if ((vQuickStartConsonant || vQuickEndConsonant) && !tempDisableKey && checkQuickConsonant()) {
            _spaceCount++;
        } else if (vRestoreIfWrongSpelling && tempDisableKey && !hasHandledMacro) {
            if (!checkRestoreIfWrongSpelling(vRestore)) {
                hCode = vDoNothing;
            }
            _spaceCount++;
        } else {
            hCode = vDoNothing;
            _spaceCount++;
        }
        
        vCheckSpelling = useSpellCheckingBefore;
        willTempOffEngine = false;
    } else if (data == KEY_DELETE) {
        hCode = vDoNothing;
        hExt = 2; //delete
        
        if (specialChar.size() > 0) {
            specialChar.pop_back();
        } else if (_spaceCount > 0) {
            _spaceCount--;
        } else {
            if (stateIndex > 0) {
                stateIndex--;
            }
            if (index > 0){
                index--;
                
                // Reset tempDisableKey to allow Vietnamese processing after backspace
                tempDisableKey = false;
                
                if (longWordHelper.size() > 0) {
                    //right shift
                    for (int i = MAX_BUFF - 1; i > 0; i--) {
                        typingWord[i] = typingWord[i-1];
                    }
                    typingWord[0] = longWordHelper.back();
                    longWordHelper.pop_back();
                    index++;
                }
                if (vCheckSpelling)
                    checkSpelling();
            }
            
            hBPC = 0;
            hNCC = 0;
            hExt = 2; //delete key
            if (index == 0) {
                startNewSession();
                specialChar.clear();
            } else {
                checkGrammar(1);
            }
        }
    } else { //START AND CHECK KEY
        if (willTempOffEngine) {
            hCode = vDoNothing;
            hExt = 3;
            return;
        }
        if (_spaceCount > 0) {
            hBPC = 0;
            hNCC = 0;
            hExt = 0;
            startNewSession();
            _spaceCount = 0;
        }

        insertState(data, isCaps);
        
        if (!IS_SPECIALKEY(data) || tempDisableKey) {
            if (vQuickTelex && IS_QUICK_TELEX_KEY(data)) {
                handleQuickTelex(data, isCaps);
                return;
            } else {
                hCode = vDoNothing;
                hBPC = 0;
                hNCC = 0;
                hExt = 3; //normal key
                insertKey(data, isCaps);
            }
        } else {
            hCode = vDoNothing;
            hExt = 3; //normal key
            handleMainKey(data, isCaps);
        }

        if (!vFreeMark && !IS_KEY_D(data)) {
            if (hCode == vDoNothing) {
                checkGrammar(-1);
            } else {
                checkGrammar(0);
            }
        }
        
        if (hCode == vRestore) {
            insertKey(data, isCaps);
            stateIndex--;
        }
        
        if (vUpperCaseFirstChar) {
            if (index == 1 && _upperCaseStatus == 2) {
                upperCaseFirstCharacter();
            }
            _upperCaseStatus = 0;
        }
        
        //case [ ]
        if (IS_BRACKET_KEY(data)) {
            if (index > 0) {
                index--;
            }
            index = 0;
            tempDisableKey = false;
            stateIndex = 0;
            hExt = 3;
            specialChar.push_back(data | (isCaps ? CAPS_MASK : 0));
        }
    }
}

void VietnameseEngine::startNewSession() {
    // Reset typing state
    index = 0;
    stateIndex = 0;
    tempDisableKey = false;
    hasHandledMacro = false;
    hasHandleQuickConsonant = false;
    
    // Clear buffers
    typingWord.fill(0);
    keyStates.fill(0);
    longWordHelper.clear();
    specialChar.clear();
    
    // Reset hook state output
    hookState.code = 0;
    hookState.backspaceCount = 0;
    hookState.newCharCount = 0;
    hookState.extCode = 0;
}

uint32_t VietnameseEngine::getCharacterCode(const uint32_t& data) {
    // TODO: Implement character code conversion
    return 0;
}

void VietnameseEngine::handleEnglishMode(const vKeyEventState& state, 
                                        const uint16_t& data, 
                                        const bool& caps, 
                                        const bool& otherControlKey) {
    // TODO: Implementation - convert from vEnglishMode
}

void VietnameseEngine::tempOffSpellChecking() {
    // TODO: Implementation
}

void VietnameseEngine::setCheckSpelling() {
    // TODO: Implementation
}

void VietnameseEngine::tempOffEngine(const bool& off) {
    willTempOffEngine = off;
}
